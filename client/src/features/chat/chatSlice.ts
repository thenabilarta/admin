/* eslint-disable @typescript-eslint/no-explicit-any */
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { RootState } from "../../app/store";
import { AxiosError } from "axios";
import { MAIN_URL } from "../../constants";
import axiosInstance from "../../utils/axiosInstance";

const initialState: any = { data: [], activeChatId: "" };

export const fetchChatData = createAsyncThunk(
  "user/Chat",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axiosInstance.get(`${MAIN_URL}/api/chat`);

      return response.data;
    } catch (error) {
      const err = error as AxiosError;

      console.log("rejected");

      console.log(err.response?.data);

      return rejectWithValue(err.response?.data);
    }
  }
);

export const chatSlice = createSlice({
  name: "chat",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setActiveChat: (state, action) => {
      const data = [];

      state.active = action.payload;
      state.activeChatId = action.payload;

      for (const s of state.data) {
        if (s.id === action.payload) {
          data.push({ ...s, active: true });
        } else {
          data.push({ ...s, active: false });
        }
      }

      state.data = data;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(fetchChatData.fulfilled, (state, action) => {
      // state.data = action.payload;
      const data = [];

      const result = action.payload;

      // state.active = action.payload;

      if (result?.length > 0) {
        for (const s of result) {
          if (s.id === state.activeChatId) {
            data.push({ ...s, active: true });
          } else {
            data.push({ ...s, active: false });
          }
        }
      }

      state.data = data;
    });
  },
});

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const getUserChat = (state: RootState) => state.chat;

export const { setActiveChat } = chatSlice.actions;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount));
//     }
//   };

export default chatSlice.reducer;
